## 16.2 map

`match` is a valid method for handling `Option`s. However, you may eventually
find heavy usage tedious; this is the case especially with operations that
are only valid with an input.

For situations where a simplistic mapping of `Some -> Some` and 
`None -> None` is needed, `Option` has a built in method called `map()`.

Multiple `map()` calls can be chained together for even more flexibility.
In the following example, `process()` easily replaces all functions previous
to it while staying compact.

<div id="active-code">
<button class="btn btn-primary" type="button" id="run-code">Run</button>
<button class="btn btn-primary" type="button" id="reset-code">Reset</button>
<div id="editor">#![allow(dead&#95;code)]

#[derive(Debug)] enum Food { Apple, Carrot, Potato }

#[derive(Debug)] struct Peeled(Food);
#[derive(Debug)] struct Chopped(Food);
#[derive(Debug)] struct Cooked(Food);

// Peeling food. If there isn't any, then just return &#96;None&#96;.
// Otherwise, return the peeled food.
fn peel(food: Option&lt;Food&gt;) -&gt; Option&lt;Peeled&gt; {
    match food {
        Some(food) =&gt; Some(Peeled(food)),
        None       =&gt; None,
    }
}

// Like above, we need to know if the peeled food exists before chopping.
fn chop(peeled: Option&lt;Peeled&gt;) -&gt; Option&lt;Chopped&gt; {
    match peeled {
        Some(Peeled(food)) =&gt; Some(Chopped(food)),
        None               =&gt; None,
    }
}

// Similar to previous checks, but using &#96;map()&#96; instead of &#96;match&#96;.
fn cook(chopped: Option&lt;Chopped&gt;) -&gt; Option&lt;Cooked&gt; {
    chopped.map(|Chopped(food)| Cooked(food))
}

// Alternatively, we can chain multiple uses of &#96;map()&#96; to simplify 
// the above process.
fn process(food: Option&lt;Food&gt;) -&gt; Option&lt;Cooked&gt; {
    food.map(|f| Peeled(f))
        .map(|Peeled(f)| Chopped(f))
        .map(|Chopped(f)| Cooked(f))
}

// It's important to know whether there's food or not before trying to eat it!
fn eat(food: Option&lt;Cooked&gt;) {
    match food {
        Some(food) =&gt; println!("Mmm. I love {:?}", food),
        None       =&gt; println!("Oh no! It wasn't edible."),
    }
}

fn main() {
    let apple = Some(Food::Apple);
    let carrot = Some(Food::Carrot);
    let potato = None;

    let cooked&#95;apple = cook(chop(peel(apple)));
    let cooked&#95;carrot = cook(chop(peel(carrot)));
    // Let's try the simpler looking &#96;process()&#96; now.
    let cooked&#95;potato = process(potato);

    eat(cooked&#95;apple);
    eat(cooked&#95;carrot);
    eat(cooked&#95;potato);
}</div>
<div id="result"></div>
</div>

### See als/rust-by-example[closures]:

[closures][closures]

[closures]: /fn/closures.html
