### 13.4.1 Testcase: empty bounds

A consequence of how bounds work is that even if a `trait` doesn't
include any functionality, you can still use it as a bound. `Eq` and
`Ord` are examples of such `trait`s from the `std` library.

<div id="active-code">
<button class="btn btn-primary" type="button" id="run-code">Run</button>
<button class="btn btn-primary" type="button" id="reset-code">Reset</button>
<div id="editor">struct Cardinal;
struct BlueJay;
struct Turkey;

trait Red {}
trait Blue {}

impl Red for Cardinal {}
impl Blue for BlueJay {}

// These functions are only valid for types which implement these
// traits. The fact that the traits are empty is irrelevant.
fn red&lt;T: Red&gt;(&#95;: &T)   -&gt; &'static str { "red" }
fn blue&lt;T: Blue&gt;(&#95;: &T) -&gt; &'static str { "blue" }

fn main() {
    let cardinal = Cardinal;
    let blue&#95;jay = BlueJay;
    let &#95;turkey   = Turkey;

    // &#96;red()&#96; won't work on a blue jay nor vice versa
    // because of the bounds.
    println!("A cardinal is {}", red(&cardinal));
    println!("A blue jay is {}", blue(&blue&#95;jay));
    //println!("A turkey is {}", red(&&#95;turkey));
    // ^ TODO: Try uncommenting this line.
}</div>
<div id="result"></div>
</div>

### See also:

[`std::cmp::Eq`][eq], [`std::cmp::Ord`s][ord], and [`trait`s][traits]

[eq]: http://doc.rust-lang.org/std/cmp/trait.Eq.html
[ord]: http://doc.rust-lang.org/std/cmp/trait.Ord.html
[traits]: /trait.html
